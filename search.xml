<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Fliter & Listener]]></title>
    <url>%2F2019%2F04%2F15%2FFliter-Listener%2F</url>
    <content type="text"><![CDATA[Fliter &amp; ListenerListener 监听器 作用监听某一事件的发生。状态的改变。 监听器内部实现机制接口回调 接口回调 A在执行循环，当循环到5的时候， 通知B。 事先先把一个对象传递给 A ， 当A 执行到5的时候，通过这个对象，来调用B中的方法。 但是注意，不是直接传递B的实例，而是传递一个接口的实例过去。 web监听器8个，3类 如何创建监听器定义一个类，实现相关的监听器接口，然后在web.xml中配置。 也可以直接通过编译器创建。 监听作用域的创建和销毁作用域 —— 对应的类 ——- 对应的监听器接口 request — httpServletRequest —– ServletRequestListener session — httpSession —- HttpSessionListener application — ServletContext——- ServletContextListener 1.request — httpServletRequest —– ServletRequestListener1234567891011121314151617import javax.servlet.ServletContextEvent;import javax.servlet.ServletContextListener;import javax.servlet.ServletRequestEvent;import javax.servlet.ServletRequestListener;public class listenertest2 implements ServletRequestListener&#123; //监听作用域对象的销毁 public void requestDestroyed(ServletRequestEvent sre) &#123; //这样写是为了直观看到监听器是否被使用，实际项目中根据需求书写 System.out.println("RequestListener 销毁了"); &#125; //监听作用域对象的创建 public void requestInitialized(ServletRequestEvent sre) &#123; //这样写是为了直观看到监听器是否被使用，实际项目中根据需求书写 System.out.println("RequestListener 创建了"); &#125;&#125; 作用监听request对象的创建和销毁 作用域1234567request创建: 访问服务器上的任意资源都会有请求出现。 访问 html： 会 访问 jsp: 会 访问 servlet : 会 request销毁： 服务器已经对这次请求作出了响应。 2.session — httpSession —- HttpSessionListener1234567891011121314151617import javax.servlet.ServletContextEvent;import javax.servlet.ServletContextListener;import javax.servlet.ServletRequestEvent;import javax.servlet.ServletRequestListener;import javax.servlet.http.HttpSessionEvent;import javax.servlet.http.HttpSessionListener;public class listenertest3 implements HttpSessionListener&#123; //监听作用域对象的创建 public void sessionCreated(HttpSessionEvent se) &#123; System.out.println("SessionListener 创建了"); &#125; //监听作用域对象的销毁 public void sessionDestroyed(HttpSessionEvent se) &#123; System.out.println("SessionListener 销毁了"); &#125;&#125; 作用监听session对象的创建与销毁 统计在线人数. 作用域12345678910session的创建 只要调用getSession html: 不会 jsp: 会 getSession(); servlet: 会session的销毁 超时 30分钟 非正常关闭 销毁​ 正常关闭服务器(序列化) 3.application — ServletContext——- ServletContextListener12345678910111213import javax.servlet.ServletContextEvent;import javax.servlet.ServletContextListener;public class listenertest1 implements ServletContextListener&#123; //监听作用域对象的创建 public void contextInitialized(ServletContextEvent sce) &#123; System.out.println("ContextListener 创建了"); &#125; //监听作用域对象的销毁 public void contextDestroyed(ServletContextEvent sce) &#123; System.out.println("ContextListener 销毁了"); &#125;&#125; 作用监听application 对象的创建与销毁 利用它来，在servletcontext创建的时候， 完成自己想要的初始化工作 执行自定义任务调度。 执行某一个任务。 Timer 作用域servletcontext创建： ​ 启动服务器的时候 servletContext销毁： ​ 关闭服务器. 从服务器移除项目 监听三个作用域属性状态变更作用域 ——— 对应监听其属性的监听器接口 servletContext — ServletContextAttributeListener request — ServletRequestAttributeListener session — HttpSessionAttributeListener servletContext — ServletContextAttributeListener request — ServletRequestAttributeListener session — HttpSessionAttributeListener 监听HttpSession中的存值状态这一类监听器不用注册 HttpSessionBindingListener123456789101. 让javaBean 实现该接口即可@Overridepublic void valueBound(HttpSessionBindingEvent event) &#123; System.out.println("对象被绑定进来了");&#125;@Overridepublic void valueUnbound(HttpSessionBindingEvent event) &#123; System.out.println("对象被解除绑定");&#125; 作用监听对象与session 绑定和解除绑定 的动作 HttpSessionActivationListener12345678910111213141516171819202122232425import java.io.Serializable;import javax.servlet.http.HttpSessionActivationListener;import javax.servlet.http.HttpSessionEvent;public class bean02 implements HttpSessionActivationListener,Serializable &#123; int a; public bean02(int a) &#123; super(); this.a = a; &#125; //get和set方法得写上不然通过jsp的EL表达式取不到值 public int getA() &#123; return a; &#125; public void setA(int a) &#123; this.a = a; &#125; public void sessionWillPassivate(HttpSessionEvent se) &#123; System.out.println("sessoin 钝化"); &#125; public void sessionDidActivate(HttpSessionEvent se) &#123; System.out.println("sessoin 活化"); &#125;&#125; 作用用于监听现在session的值 是 钝化 （序列化）还是活化 （反序列化）的动作 钝化 （序列化）把内存中的数据 存储到硬盘上 活化 （反序列化）把硬盘中的数据读取到内存中。 session的钝化活化的用意何在session中的值可能会很多， 并且我们有很长一段时间不使用这个内存中的值， 那么可以考虑把session的值可以存储到硬盘上【钝化】，等下一次在使用的时候，在从硬盘上提取出来。 【活化】 如何让session的在一定时间内钝化.做配置即可 123456789101112131415161718192021221. 在tomcat里面 conf/context.xml 里面配置 对所有的运行在这个服务器的项目生效 2. 在conf/Catalina/localhost/context.xml 配置 对 localhost生效。 localhost:80803. 在自己的web工程项目中的 META-INF/context.xml 只对当前的工程生效。 maxIdleSwap ： 1分钟不用就钝化 directory ： 钝化后的那个文件存放的目录位置，可自定义。 D:\tomcat\apache-tomcat-7.0.52\work\Catalina\localhost\ListenerDemo\wf &lt;Context&gt; &lt;Manager className=&quot;org.apache.catalina.session.PersistentManager&quot; maxIdleSwap=&quot;1&quot;&gt; &lt;Store className=&quot;org.apache.catalina.session.FileStore&quot; directory=&quot;wf&quot;/&gt; &lt;/Manager&gt; &lt;/Context&gt; Filter 过滤器，对客户端发出的请求进行过滤。在浏览器发出请求后，就由过滤器进行过滤，然后才交给servlet处理。其实过滤器起到拦截作用。 作用 对一些敏感词汇进行过滤 统一设置编码 自动登录 … 如何使用filter1.定义一个类实现Filter接口 123456789101112131415161718192021222324import java.io.IOException;import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;public class filter02 implements Filter &#123; //过滤器销毁时调用 public void destroy() &#123; &#125; //在执行过滤时调用 public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println("fliter02"); //chian的作用是当过滤器检测后，如果不用把请求过滤掉，那么就使用chain把请求传递到下一个地方。 chain.doFilter(request, response); &#125; //过滤器创建时调用 public void init(FilterConfig fConfig) throws ServletException &#123; &#125;&#125; 2.过滤器注册 在web.xml中注册和servlet注册方法基本一样 123456789&lt;filter&gt; &lt;display-name&gt;FilterDemo&lt;/display-name&gt; &lt;filter-name&gt;filter02&lt;/filter-name&gt; &lt;filter-class&gt;test4.filter02&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;filter02&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; Filter的生命周期创建 ​ 在服务器启动的时候就创建。 销毁 ​ 服务器停止的时候。 Filter执行顺序 客户端发出请求，先经过过滤器， 如果过滤器放行，那么才能到servlet 如果有多个过滤器， 那么他们会按照注册的映射顺序 来 排队。 只要有一个过滤器， 不放行，那么后面排队的过滤器以及咱们的servlet都不会收到请求。 Filter细节： init方法的参数 FilterConfig , 可以用于获取filter在注册的名字 以及初始化参数。 其实这里的设计的初衷与ServletConfig是一样的。 如果想放行，那么在doFilter 方法里面操作，使用参数 chain 1chain.doFilter(request, response); 放行， 让请求到达下一个目标。 /* 写法格式与servlet一样。 全路径匹配 以 / 开始 /LoginServlet 以目录匹配 以 / 开始 以 * 结束 /demo01/* 以后缀名匹配 以 * 开始 以后缀名结束 .jsp .html *.do 针对 dispatcher 设置 REQUEST ： 只要是请求过来，都拦截，默认就是REQUESTFORWARD : 只要是转发都拦截。ERROR ： 页面出错发生跳转INCLUDE ： 包含页面的时候就拦截。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>javaweb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis（1）入门]]></title>
    <url>%2F2019%2F04%2F15%2FMybatis%EF%BC%881%EF%BC%89%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Mybatis（1）入门1、mybatis的概述mybatis是一个持久层框架，用java编写的。它封装了jdbc操作的很多细节，使开发者只需要关注sql语句本身，而无需关注注册驱动，创建连接等繁杂过程它使用了ORM思想实现了结果集的封装。 ORM： Object Relational Mappging 对象关系映射 简单的说： 就是把数据库表和实体类及实体类的属性对应起来 让我们可以操作实体类就实现操作数据库表。123user Userid userIduser_name userName 今天我们需要做到实体类中的属性和数据库表的字段名称保持一致。123user Userid iduser_name user_name 2、mybatis的入门mybatis的环境搭建 2.1、创建maven工程并导入坐标配置\pom.xml 该文件导入了所有在工程中要使用的jar包。 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;wf&lt;/groupId&gt; &lt;artifactId&gt;day01_ssm_01mybatis&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2.2、创建实体类和dao的接口创建实体类src\main\java\domain\User.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package domain;import java.io.Serializable;import java.util.Date;import java.util.Objects;public class User implements Serializable &#123; private Integer id; private String username; private Date birthday; private String sex; private String address; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return "User&#123;" + "id=" + id + ", username='" + username + '\'' + ", birthday=" + birthday + ", sex='" + sex + '\'' + ", address='" + address + '\'' + '&#125;'; &#125;&#125; 配置dao接口\src\main\java\dao\IUserDao.java 12345678910111213141516package dao;import domain.User;import java.util.List;/** * 用户持久层接口 */public interface IUserDao &#123; /** * 查询所有操作 */ List&lt;User&gt; findAll();&#125; 2.3、创建Mybatis的主配置文件主配置文件\src\main\resources\SqlMapConfig.xml 12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;!--mybatis的主配置文件--&gt;&lt;configuration&gt; &lt;!--配置环境--&gt; &lt;environments default="mysql"&gt; &lt;!--配置MySQL的环境--&gt; &lt;environment id="mysql"&gt; &lt;!--配置事务类型--&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;!--配置数据源（连接池）--&gt; &lt;dataSource type="POOLED"&gt; &lt;!--配置连接池的基本信息4个--&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql:///eesy_mybatis"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="123456"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件--&gt; &lt;mappers&gt; &lt;mapper resource="dao/IUserDao.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 2.4、创建映射配置文件映射配置文件\src\main\resources\dao\IUserDao.xml 123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="dao.IUserDao"&gt; &lt;!--配置查询所有--&gt; &lt;select id="findAll" resultType="domain.User"&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 2.5、环境搭建的注意事项第一个：创建IUserDao.xml 和 IUserDao.java时名称是为了和我们之前的知识保持一致。 在Mybatis中它把持久层的操作接口名称和映射文件也叫做：Mapper 所以：IUserDao 和 IUserMapper是一样的第二个：在idea中创建目录的时候，它和包是不一样的 包在创建时：com.itheima.dao它是三级结构 目录在创建时：com.itheima.dao是一级目录第三个：mybatis的映射配置文件位置必须和dao接口的包结构相同第四个：映射配置文件的mapper标签namespace属性的取值必须是dao接口的全限定类名第五个：映射配置文件的操作配置（select），id属性的取值必须是dao接口的方法名 当我们遵从了第三，四，五点之后，我们在开发中就无须再写dao的实现类。 2.6、mybatis的入门案例第一步：读取配置文件第二步：创建SqlSessionFactory工厂第三步：创建SqlSession第四步：创建Dao接口的代理对象第五步：执行dao中的方法第六步：释放资源 注意事项： 不要忘记在映射配置中告知mybatis要封装到哪个实体类中(resultType) 123&lt;select id="findAll" resultType="domain.User"&gt; select * from user&lt;/select&gt; ​ 配置的方式：指定实体类的全限定类名 2.6.1、基于配置文件入门案例\src\test\java\test\MybatisTest.java 1234567891011121314151617181920212223242526272829303132333435package test;import dao.IUserDao;import domain.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.InputStream;import java.util.List;public class MybatisTest &#123; //入门案例 public static void main(String[] args) throws Exception &#123; //1 读取配置文件 InputStream in = Resources.getResourceAsStream("SqlMapConfig.xml"); //2 创建一个sqlSessionFactory工厂 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); SqlSessionFactory factory = builder.build(in); //3 使用工厂生成SqlSesasion对象 SqlSession session = factory.openSession(); //4 使用SqlSesasion对象创建Dao接口的代理对象 IUserDao userDao = session.getMapper(IUserDao.class); //5 使用代理对象执行方法 List&lt;User&gt; all = userDao.findAll(); for (User user:all) &#123; System.out.println(user); &#125; //6 释放资源 session.close(); in.close(); &#125;&#125; 2.6.2、mybatis基于注解的入门案例把IUserDao.xml移除，在dao接口的方法上使用@Select注解，并且指定SQL语句 1234567891011121314151617package dao;import domain.User;import org.apache.ibatis.annotations.Select;import java.util.List;/** * 用户持久层接口 */public interface IUserDao &#123; /** * 查询所有操作 */ @Select("select * from user") List&lt;User&gt; findAll();&#125; 同时需要在SqlMapConfig.xml中的mapper配置时，使用class属性指定dao接口的全限定类名。 123&lt;mappers&gt; &lt;mapper class="dao.IUserDao"/&gt;&lt;/mappers&gt; 明确： 我们在实际开发中，都是越简便越好，所以都是采用不写dao实现类的方式。 不管使用XML还是注解配置。 但是Mybatis它是支持写dao实现类的。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>javaee</tag>
        <tag>ssm框架</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[object类的概述]]></title>
    <url>%2F2019%2F04%2F15%2Fobject%E7%B1%BB%E7%9A%84%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[object类的概述 object类是类层次结构的根类，每个类都使用object作为超类。 即每个类都直接或间接的继承object类。 object类中方法介绍hashCode1public int hashCode():返回对象的哈希码值。 注意：哈希值是根据哈希算法计算出来的一个值，该值与地址值有关，但不是实际的值。可理解为地址值。 getClass1public final Class&lt;?&gt; getClass():返回object运行时类，得到一个Class对象。返回的 Class 对象是由所表示类的 static synchronized 方法锁定的对象。 在Class类中有getname()方法以 String 的形式返回此 Class 对象所表示的实体（类、接口、数组类、基本类型或 void）名称。 toString123456789101112public String toString():返回该对象的字符串表示。toString方法返回一个字符串，它的值等于： getClass().getName() + '@' + Integer.toHexString(hashCode())ps：Integer.toHexString（）为Integer类下一静态方法，public static String toHexString(int i)：以十六进制（基数 16）无符号整数形式返回一个整数参数的字符串表示形式。源码：public String toString() &#123; return getClass().getName() + "@"Integer.toHexString(hashCode()); &#125; 但toString方法返回的信息是无意义的。所以建议所以子类重写改方法。 重写的格式为：把所有成员变量值返回即可。但这样不是最好，自动生成即可。 12345678class Test&#123; int num; @Override public String toString() &#123; return "Test [num=" + num + "]"; &#125;&#125; 直接输出一个对象的名称，就是调用改对象的toString()方法。 equals12345public boolean equals(Object obj):指示其他某个对象是否与此对象“相等”。源码：public boolean equals(Object obj) &#123; return (this == obj); &#125; ==: ​ 基本类型：比较值是否相等。 ​ 引用类型：比较其地址值是否相等。 该方法，默认情况比较的是地址值，但是比较地址值意义不大，所以要重写改方法。 在方法重写时比较对象的成员变量值是否相同。 重写代码优化：提高效率，提高程序健壮性。 要想做到最好优化还是自动生成。（自动生成时会和hascode()方法一起生成。） 1234567891011121314151617181920212223242526272829303132class Test&#123; int num; String sfa; @Override public int hashCode() &#123; final int prime = 31; int result = 1; result = prime * result + num; result = prime * result + ((sfa == null) ? 0 : sfa.hashCode()); return result; &#125; @Override public boolean equals(Object obj) &#123; if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Test other = (Test) obj; if (num != other.num) return false; if (sfa == null) &#123; if (other.sfa != null) return false; &#125; else if (!sfa.equals(other.sfa)) return false; return true; &#125;&#125; 注：此为eclipse生成可能与idea生成的有所不同，但效果一样。 finalize1protected void finalize() throws Throwable :当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。 clone12protected Object clone() throws CloneNotSupportedException:创建并返回此对象的一个副本。“副本”的准确含义可能依赖于对象的类。 Cloneable：此类实现了Cloneable接口，以示Object.clone()方法合法的进行对该类的按字段复制。 Cloneable是一个标记接口，表明实现该接口的类可以实现对象的复制。]]></content>
      <categories>
        <category>Javase</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F14%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
