<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[动态代理解决编码问题]]></title>
    <url>%2F2019%2F04%2F16%2F%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%A7%A3%E5%86%B3%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[动态代理解决编码问题1.设计模式出现原因：软件开发过程中，遇到相似问题，将问题的解决方法抽取模型（套路） 常见设计模式：单例，工厂，适配器，装饰者，动态代理。 2.装饰者模式简单介绍谷歌汽车开发场景1.Java定义了汽车开发约定 12interface ICar&#123;start , run , stop&#125;calss GooleCar implements ICar&#123;&#125; 2.目的：将谷歌Car接入导生态平台时，增强汽车功能 3.问题：谷歌Car的代码无法获取，且无法继承，不能直接操作其源码 装饰者模式 场景：在二次开发时，无法获取源码，且不能被继承的情况下，对以存在对象上的功能进行增强。 前提：可以获取被装饰的对象的所有实现接口 实现思路：自定义对象继承被装饰对象的接口，为自定义装饰类传递被装饰的对象 装饰者模式的弊端 如果被实现的接口中方法过的，则其所有方法都要被重写，装饰类会显得冗杂。 3.动态代理解决装饰者模式的弊端 a.原理通过虚拟机在内存创建类似MyCar.Class文件 要创建MyCar.Class文件来告诉虚拟机： ​ 1.被创建的字节码文件上需要哪些方法 字节码加载器jdk有一些程序专业将各种字节码文件加载到内存，这类程序称为字节码加载器 如何将字节码文件class文件加载到内存？底层提供IO技术，获取文件中的数据加载到内存。 字节码加载器有3种 123456789101112131415161718public class TestClassLoader &#123; public static void main(String[] args) &#123; //获取String类的加载器ClassLoader classLoader = String.class.getClassLoader();System.out.println(classLoader);//由于String.class ,int.class等字节码文件需要频繁的被加载内存,速度必须快,底层用其他语言来实现c c++ //获取ext(extendtion)包下的某个类的字节码加载器 ExtClassLoader:扩展类加载器ClassLoader classLoader2 = sun.net.spi.nameservice.dns.DNSNameService.class.getClassLoader(); System.out.println(classLoader2); //应用类:程序员实现的所有的类都属于应用类//获取应用类加载器 AppClassLoaderClassLoader classLoader3 = TestClassLoader.class.getClassLoader();System.out.println(classLoader3); &#125;&#125; 动态代理简单案例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.util.Arrays;public class TestCar &#123; public static void main(String[] args) &#123; //1param: 固定值: 告诉虚拟机用哪个字节码加载器加载内存中创建出的字节码文件//2param: 告诉虚拟机内存中正在被创建的字节码文件中应该有哪些方法//3param: 告诉虚拟机正在被创建的字节码上的各个方法如何处理ICar car=(ICar)Proxy.newProxyInstance(TestCar.class.getClassLoader(), GoogleCar.class.getInterfaces(),new InvocationHandler() &#123; //method:代表正在执行的方法//args:代表正在执行的方法中的参数//Object:代表方法执行完毕之后的返回值@Overridepublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //经过测试得知:method代表当前正在执行的每个方法 //System.out.println(method.getName()); //执行当前的方法 //method.invoke(new GoogleCar(), args);//代表每个方法执行完毕之后返回对象 Object obj=null; if(method.getName().equalsIgnoreCase("start"))&#123; System.out.println("检查天气是否良好"); //打印args中的内容 System.out.println(Arrays.toString(args)); obj=method.invoke(new GoogleCar(), args); System.out.println("检查路况是否拥堵"); &#125;else&#123; obj=method.invoke(new GoogleCar(), args); &#125; return obj; &#125;&#125;);String cc=car.start(1,4);System.out.println(cc);car.run();car.stop(); &#125;&#125;class MyCC implements InvocationHandler&#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; return null; &#125;&#125; 动态代理解决servlet的get请求的中文编码问题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import java.io.IOException;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletRequest;public class EncodingFilter implements Filter &#123; public EncodingFilter() &#123; &#125; public void destroy() &#123; &#125; public void init(FilterConfig fConfig) throws ServletException &#123; &#125; public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; //将request对象转换为HttpServletRequest final HttpServletRequest req=(HttpServletRequest)request; //让JDK在内存中生成代理对象:增强了req对象上的getParameter(name);API HttpServletRequest myReq=(HttpServletRequest)Proxy.newProxyInstance(EncodingFilter.class.getClassLoader(), req.getClass().getInterfaces(), new InvocationHandler() &#123; @Overridepublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object obj=null; if(method.getName().equalsIgnoreCase("getParameter"))&#123; //获取本次请求方式 String md=req.getMethod(); if("get".equalsIgnoreCase(md))&#123; //get方式的请求 //调用req对象上的getParameter方法 String v=(String)method.invoke(req, args); //转码 String vv=new String(v.getBytes("iso-8859-1"),"utf-8"); return vv; &#125;else&#123; //post方式的请求 req.setCharacterEncoding("utf-8"); obj=method.invoke(req, args); &#125; &#125;else&#123; obj=method.invoke(req, args); &#125; return obj; &#125;&#125;); //打印代理对象哈希码System.out.println(myReq.hashCode()); //将代理对象放行chain.doFilter(myReq, response); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>java</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis(2)CRUD]]></title>
    <url>%2F2019%2F04%2F16%2Fmybatis-2-CRUD%2F</url>
    <content type="text"><![CDATA[Mybatis（2）CRUD1、基于代理Dao实现CRUD操作使用要求：1、持久层接口（src\main\java\dao\IUserDao.java）和持久层接口的映射配置（src\main\resources\dao\IUserDao.xml）必须在相同的包下2、持久层映射配置中 mapper 标签的 namespace 属性取值必须是持久层接口的全限定类名 1&lt;mapper namespace="dao.IUserDao"&gt; 3、SQL 语句的配置标签select ,insert,delete,update的 id 属性必须和持久层接口的方法名相同。 123456持久层接口的方法/*** 查询所有数据* @return*/List&lt;User&gt; findAll(); 1234SQL 语句的配置标签id 属性&lt;select id="findAll" resultType="domain.User"&gt; select * from user &lt;/select&gt; 关于测试类的一些细节： 12345678910111213141516171819202122232425262728293031package test;import bao;//此处是要导入的包，为了节约空间所以省略public class MybatisTest &#123; /** * 测试mybatis的CRUD操作 */ //全局属性用于实现对应操作 InputStream in; SqlSession sqlSession; IUserDao uesrdao; //before注释说明该方法最先执行相当于servlet中的init方法 //用于给对应对象赋值用于后续的增删改查操作 //这几个对象是通用的所以提出来 //也可以写工具类来实现 @Before public void init() throws Exception &#123; in = Resources.getResourceAsStream("SqlMapConfig.xml"); SqlSessionFactory build = new SqlSessionFactoryBuilder().build(in); sqlSession = build.openSession(); uesrdao = sqlSession.getMapper(IUserDao.class); &#125; //before注释说明该方法最后执行相当于servlet中的destory方法 //用于释放资源 @After public void destory() throws Exception &#123; sqlSession.commit(); sqlSession.close(); in.close(); &#125; 1.1、据根据 ID查询1.1.1、在持久层接口中添加 findById12345/** * 根据id查询用户 * @param id */ User findById(int id); 1.1.2、在用户的映射配置文件中配置123&lt;select id="findById" parameterType="int" resultType="domain.User"&gt; select * from user where id=#&#123;id&#125; &lt;/select&gt; 细节：resultType 属性：用于指定结果集的类型。 parameterType :用于指定传入参数的类型。 sql 语句中使用#{} 字符 ：它代表占位符，相当于原来 jdbc 部分所学的?，都是用于执行语句时替换实际的数据。具体的数据是由#{}里面的内容决定的。 .#{} 中内容的写法：由于数据类型是基本类型，所以此处可以随意写。 1.1.3、在测试类添加测试123456@Test public void testFindOne()&#123; //通过id查找用户 User user = uesrdao.findById(48); System.out.println(user); &#125; 1.2、添加操作1.2.1、在持久层接口中添加 addUser12345/** * 添加用户 * @param user */ void addUser(User user); 1.2.2、在用户的映射配置文件中配置1234&lt;insert id="addUser" parameterType="domain.User"&gt; insert into user (username,address,sex,birthday) value (#&#123;username&#125;,#&#123;address&#125;, #&#123;sex&#125;,#&#123;birthday&#125;) &lt;/insert&gt; 1.2.3、在测试类添加测试1234567891011@Test public void testAddUser()&#123; //添加用户 User user = new User(); user.setUsername("wf"); user.setAddress("中国"); user.setSex("男"); user.setBirthday(new Date()); //执行添加操作 uesrdao.addUser(user); &#125; 1.3、删除操作1.3.1、在持久层接口中添加 deleteUser12345/** * 添加用户 * @param user */ void addUser(User user); 1.3.2、在用户的映射配置文件中配置123&lt;delete id="deleteUser" parameterType="java.lang.Integer"&gt; delete from user where id=#&#123;id&#125; &lt;/delete&gt; 1.3.3、在测试类添加测试123456@Test public void testDeleteUser()&#123; //删除用户 uesrdao.deleteUser(49); &#125; 1.4、更新操作1.4.1、在持久层接口中添加 updateUser12345/** * 更新用户 * @param user */ void updateUser(User user); 1.4.2、在用户的映射配置文件中配置123&lt;update id="updateUser" parameterType="domain.User"&gt; update user set username=#&#123;username&#125;,address=#&#123;address&#125;,sex=#&#123;sex&#125;,birthday=#&#123;birthday&#125; &lt;/update&gt; 1.4.3、在测试类添加测试123456@Test public void testDeleteUser()&#123; //删除用户 uesrdao.deleteUser(49); &#125; 1.5、用户模糊查询1.5.1、在持久层接口中添加 findByName12345/** * 模糊查询用户信息 * @return */List&lt;User&gt; findByName(String str); 1.5.2、在用户的映射配置文件中配置12345678&lt;select id="findByName" resultType="domain.User" parameterType="String"&gt; &lt;!--select * from user where username like '%$&#123;value&#125;%'--&gt; &lt;!-- 使用上面方式模糊查询时Statment对象通过字符串拼接的方式连接sql语句 下面的sql语句使用PrepatedStatement的参数占位符有预处理， 所以下面这种方式使用的多 --&gt; select * from user where username like #&#123;str&#125;&lt;/select&gt; 1.5.3、在测试类添加测试1234567891011@Test public void testAddUser()&#123; //添加用户 User user = new User(); user.setUsername("wf"); user.setAddress("中国"); user.setSex("男"); user.setBirthday(new Date()); //执行添加操作 uesrdao.addUser(user); &#125; 在控制台输出的执行 SQL 语句如下： 1Preparing: select * from user where username like ? 我们在配置文件中没有加入%来作为模糊查询的条件，所以在传入字符串实参时，就需要给定模糊查询的标识%。配置文件中的#{username}也只是一个占位符，所以 SQL 语句显示为“？”。 1.5.4、模糊查询的另一种配置方式第一步：修改 SQL 语句的配置，配置如下： 1234&lt;!-- 根据名称模糊查询 --&gt;&lt;select id="findByName" parameterType="string" resultType="com.itheima.domain.User"&gt;select * from user where username like '%$&#123;value&#125;%'&lt;/select&gt; 我们在上面将原来的#{}占位符，改成了${value}。注意如果用模糊查询的这种写法，那么${value}的写法就是固定的，不能写成其它名字。 第二步：测试 1234567891011/*** 测试模糊查询操作*/@Testpublic void testFindByName()&#123;//5.执行查询一个方法List&lt;User&gt; users = userDao.findByName("王");for(User user : users)&#123;System.out.println(user);&#125;&#125; 在控制台输出的执行 SQL 语句如下： 1Preparing: select * from user where username like ‘%王% ’ 可以发现，我们在程序代码中就不需要加入模糊查询的匹配符%了，这两种方式的实现效果是一样的，但执行的语句是不一样的。 1.5.5、模糊查询的${value}我们一起来看 TextSqlNode 类的源码： 1234567891011121314public String handleToken(String content) &#123; Object parameter = this.context.getBindings().get("_parameter"); if (parameter == null) &#123; this.context.getBindings().put("value", (Object)null); &#125; else if (SimpleTypeRegistry.isSimpleType(parameter.getClass())) &#123; this.context.getBindings().put("value", parameter); &#125; Object value = OgnlCache.getValue(content, this.context.getBindings()); String srtValue = value == null ? "" : String.valueOf(value); this.checkInjection(srtValue); return srtValue;&#125; 这就说明了源码中指定了读取的 key 的名字就是”value”，所以我们在绑定参数时就只能叫 value 的名字了。 1.6、查询使用聚合函数1.6.1、在持久层接口中添加 findTotal12345/** * 添加用户 * @param user */ void addUser(User user); 1.6.2、在用户的映射配置文件中配置1234&lt;!-- 查询总记录条数 --&gt;&lt;select id="findTotal" resultType="int"&gt;select count(*) from user;&lt;/select&gt; 1.6.3、在测试类添加测试123456@Testpublic void testFindTotal() throws Exception &#123;//6.执行操作int res = userDao.findTotal();System.out.println(res);&#125; 1.7、Mybatis 与 与 JDBC 编程的比较1.数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。解决：在 SqlMapConfig.xml 中配置数据链接池，使用连接池管理数据库链接。 2.Sql 语句写在代码中造成代码不易维护，实际应用 sql 变化的可能较大，sql 变动需要改变 java 代码。解决：将 Sql 语句配置在 XXXXmapper.xml 文件中与 java 代码分离。 3.向sql语句传参数麻烦，因为sql语句的where 条件不一定，可能多也可能少，占位符需要和参数对应。解决：Mybatis自动将 java 对象映射至 sql 语句，通过 statement 中的 parameterType 定义输入参数的类型。 4.对结果集解析麻烦，sql 变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成 pojo 对象解析比较方便。解决：Mybatis自动将 sql执行结果映射至 java 对象，通过 statement 中的 resultType 定义输出结果的类型。 2、 Mybatis 的参数深入2.1、使用说明​ 我们在上一节中已经介绍了 SQL 语句传参，使用标签的 parameterType 属性来设定。该属性的取值可以是基本类型，引用类型（例如:String 类型），还可以是实体类类型（POJO 类）。同时也可以使用实体类的包装类，本节将介绍如何使用实体类的包装类作为参数传递。 2.2、注意事项​ 基本类型和 String我们可以直接写类型名称 ，也可以使用包名 . 类名的方式 ，例如 ：java.lang.String。 ​ 实体类类型，目前我们只能使用全限定类名。 ​ 究其原因，是 mybaits 在加载时已经把常用的数据类型注册了别名，从而我们在使用时可以不写包名，而我们的是实体类并没有注册别名，所以必须写全限定类名。 2.3 递传递pojo包装对象开发中通过 pojo 传递查询条件 ，查询条件是综合的查询条件，不仅包括用户查询条件还包括其它的查询条件（比如将用户购买商品信息也作为查询条件），这时可以使用包装对象传递输入参数。Pojo 类中包含 pojo。需求：根据用户名查询用户信息，查询条件放到 QueryVo 的 user 属性中。 2.3.1、编写QueryVo12345678910111213package domain;public class QueryVo &#123; private User user; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125;&#125; 2.3.2、在持久层接口中添加 findByVo12345/*** 模糊查询用户信息* @return*/List&lt;User&gt; findByVo(QueryVo vo); 2.3.3、在用户的映射配置文件中配置123&lt;select id="findByVo" resultType="domain.User" parameterType="domain.QueryVo"&gt; select * from user where username like #&#123;user.username&#125;&lt;/select&gt; 1.2.3、在测试类添加测试1234567891011121314@Testpublic void testFindByVo()&#123; //通过模糊查询查找用户 QueryVo vo = new QueryVo(); User user = new User(); user.setUsername("%g%"); vo.setUser(user); List&lt;User&gt; users = uesrdao.findByVo(vo); for(User u:users)&#123; System.out.println(u); &#125;&#125; 3、Mybatis 的输出结果封装3.1 resultType​ resultType 属性可以指定结果集的类型，它支持基本类型和实体类类型。 我们在前面的 CRUD 案例中已经对此属性进行过应用了。 需要注意的是，它和 parameterType 一样，如果注册过类型别名的，可以直接使用别名。没有注册过的必须使用全限定类名。例如：我们的实体类此时必须是全限定类名（今天最后一个章节会讲解如何配置实体类的别名） 同时，当是实体类名称是，还有一个要求， 实体类中的属性名称必须和查询语句中的列名保持一致，否则无法实现封装。 3.1.1 基本类型示例3.1.1.1 Dao 接口12345/**- 查询总记录条数- @return */int findTotal(); 3.1.1.2 映射配置1234&lt;!-- 查询总记录条数 --&gt;&lt;select id="findTotal" resultType="int"&gt;select count(*) from user;&lt;/select&gt; 3.1.2 实体类类型示例3.1.2.1 Dao 接口12345/*** 查询所有用户* @return */ List&lt;User&gt; findAll(); 3.1.2.2 映射配置1234&lt;!-- 配置查询所有操作 --&gt;&lt;select id="findAll" resultType="com.itheima.domain.User"&gt;select * from user&lt;/select&gt; 3.1.3 特殊情况示例3.1.3.1 修改实体类实体类代码如下：( 此时的实体类属性和数据库表的列名已经不一致了) 123456789101112131415/**** &lt;p&gt;Title: User&lt;/p&gt;* &lt;p&gt;Description: 用户的实体类&lt;/p&gt; */ public class User implements Serializable &#123; private Integer userId; private String userName; private Date userBirthday; private String userSex; private String userAddress; public Integer getUserId() &#123; return userId; &#125; //此处自动生成get和set及tostring方法 3.1.3.2 Dao 接口123456/*** 查询所有用户* @return */ List&lt;User&gt; findAll(); 3 .1.3.3 映射配置1234&lt;!-- 配置查询所有操作 --&gt;&lt;select id="findAll" resultType="com.itheima.domain.User"&gt;select * from user&lt;/select&gt; 3.1.3.4 测试查询结果1234567@Testpublic void testFindAll() &#123;List&lt;User&gt; users = userDao.findAll();for(User user : users) &#123;System.out.println(user);&#125;&#125; 结果： User{userId=null, userName=’gx’, userAddress=’null’, userSex=’null’, userBirthday=null}User{userId=null, userName=’gx’, userAddress=’null’, userSex=’null’, userBirthday=null}User{userId=null, userName=’gx’, userAddress=’null’, userSex=’null’, userBirthday=null}User{userId=null, userName=’gx’, userAddress=’null’, userSex=’null’, userBirthday=null} 为什么名称会有值呢？因为：mysql 在 在 windows private String userName; 3.1.3.5 修改映射配置使用别名查询 12345&lt;!-- 配置查询所有操作 --&gt;&lt;select id="findAll" resultType="com.itheima.domain.User"&gt;select id as userId,username as userName,birthday as userBirthday,sex as userSex,address as userAddress from user&lt;/select&gt; 运行结果： User{userId=41, userName=’gx’, userAddress=’中国’, userSex=’女’, userBirthday=Mon Apr 15 21:28:56 CST 2019}User{userId=42, userName=’gx’, userAddress=’中国’, userSex=’女’, userBirthday=Mon Apr 15 21:28:56 CST 2019}User{userId=43, userName=’gx’, userAddress=’中国’, userSex=’女’, userBirthday=Mon Apr 15 21:28:56 CST 2019}User{userId=45, userName=’gx’, userAddress=’中国’, userSex=’女’, userBirthday=Mon Apr 15 21:28:56 CST 2019} 如果我们的查询很多，都使用别名的话写起来岂不是很麻烦，有没有别的解决办法呢？ 3.2 resultMap​ resultMap 标签可以建立查询的列名和实体类的属性名称不一致时建立对应关系。从而实现封装。 在 select 标签中使用 resultMap 属性指定引用即可。同时 resultMap 可以实现将查询结果映射为复杂类型的 pojo，比如在查询结果映射对象中包括 pojo 和 list 实现一对一查询和一对多查询。 3.2.1 定义 resultMap123456789101112131415&lt;!-- 建立 User 实体和数据库表的对应关系type 属性：指定实体类的全限定类名id 属性：给定一个唯一标识，是给查询 select 标签引用用的。--&gt;&lt;resultMap type="com.itheima.domain.User" id="userMap"&gt;&lt;id column="id" property="userId"/&gt;&lt;result column="username" property="userName"/&gt;&lt;result column="sex" property="userSex"/&gt;&lt;result column="address" property="userAddress"/&gt;&lt;result column="birthday" property="userBirthday"/&gt;&lt;/resultMap&gt;id 标签：用于指定主键字段result 标签：用于指定非主键字段column 属性：用于指定数据库列名property 属性：用于指定实体类属性名称 3.2.2 映射配置1234&lt;!-- 配置查询所有操作 --&gt;&lt;select id="findAll" resultMap="userMap"&gt;select * from user&lt;/select&gt; 3.2.3 测试结果1234567@Testpublic void testFindAll() &#123;List&lt;User&gt; users = userDao.findAll();for(User user : users) &#123;System.out.println(user);&#125;&#125; 运行结果： User{userId=41, userName=’gx’, userAddress=’中国’, userSex=’女’, userBirthday=Mon Apr 15 21:28:56 CST 2019}User{userId=42, userName=’gx’, userAddress=’中国’, userSex=’女’, userBirthday=Mon Apr 15 21:28:56 CST 2019}User{userId=43, userName=’gx’, userAddress=’中国’, userSex=’女’, userBirthday=Mon Apr 15 21:28:56 CST 2019}User{userId=45, userName=’gx’, userAddress=’中国’, userSex=’女’, userBirthday=Mon Apr 15 21:28:56 CST 2019}]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>javaee</tag>
        <tag>ssm框架</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fliter & Listener]]></title>
    <url>%2F2019%2F04%2F15%2FFliter-Listener%2F</url>
    <content type="text"><![CDATA[Fliter &amp; ListenerListener 监听器 作用监听某一事件的发生。状态的改变。 监听器内部实现机制接口回调 接口回调 A在执行循环，当循环到5的时候， 通知B。 事先先把一个对象传递给 A ， 当A 执行到5的时候，通过这个对象，来调用B中的方法。 但是注意，不是直接传递B的实例，而是传递一个接口的实例过去。 web监听器8个，3类 如何创建监听器定义一个类，实现相关的监听器接口，然后在web.xml中配置。 也可以直接通过编译器创建。 监听作用域的创建和销毁作用域 —— 对应的类 ——- 对应的监听器接口 request — httpServletRequest —– ServletRequestListener session — httpSession —- HttpSessionListener application — ServletContext——- ServletContextListener 1.request — httpServletRequest —– ServletRequestListener1234567891011121314151617import javax.servlet.ServletContextEvent;import javax.servlet.ServletContextListener;import javax.servlet.ServletRequestEvent;import javax.servlet.ServletRequestListener;public class listenertest2 implements ServletRequestListener&#123; //监听作用域对象的销毁 public void requestDestroyed(ServletRequestEvent sre) &#123; //这样写是为了直观看到监听器是否被使用，实际项目中根据需求书写 System.out.println("RequestListener 销毁了"); &#125; //监听作用域对象的创建 public void requestInitialized(ServletRequestEvent sre) &#123; //这样写是为了直观看到监听器是否被使用，实际项目中根据需求书写 System.out.println("RequestListener 创建了"); &#125;&#125; 作用监听request对象的创建和销毁 作用域1234567request创建: 访问服务器上的任意资源都会有请求出现。 访问 html： 会 访问 jsp: 会 访问 servlet : 会 request销毁： 服务器已经对这次请求作出了响应。 2.session — httpSession —- HttpSessionListener1234567891011121314151617import javax.servlet.ServletContextEvent;import javax.servlet.ServletContextListener;import javax.servlet.ServletRequestEvent;import javax.servlet.ServletRequestListener;import javax.servlet.http.HttpSessionEvent;import javax.servlet.http.HttpSessionListener;public class listenertest3 implements HttpSessionListener&#123; //监听作用域对象的创建 public void sessionCreated(HttpSessionEvent se) &#123; System.out.println("SessionListener 创建了"); &#125; //监听作用域对象的销毁 public void sessionDestroyed(HttpSessionEvent se) &#123; System.out.println("SessionListener 销毁了"); &#125;&#125; 作用监听session对象的创建与销毁 统计在线人数. 作用域12345678910session的创建 只要调用getSession html: 不会 jsp: 会 getSession(); servlet: 会session的销毁 超时 30分钟 非正常关闭 销毁​ 正常关闭服务器(序列化) 3.application — ServletContext——- ServletContextListener12345678910111213import javax.servlet.ServletContextEvent;import javax.servlet.ServletContextListener;public class listenertest1 implements ServletContextListener&#123; //监听作用域对象的创建 public void contextInitialized(ServletContextEvent sce) &#123; System.out.println("ContextListener 创建了"); &#125; //监听作用域对象的销毁 public void contextDestroyed(ServletContextEvent sce) &#123; System.out.println("ContextListener 销毁了"); &#125;&#125; 作用监听application 对象的创建与销毁 利用它来，在servletcontext创建的时候， 完成自己想要的初始化工作 执行自定义任务调度。 执行某一个任务。 Timer 作用域servletcontext创建： ​ 启动服务器的时候 servletContext销毁： ​ 关闭服务器. 从服务器移除项目 监听三个作用域属性状态变更作用域 ——— 对应监听其属性的监听器接口 servletContext — ServletContextAttributeListener request — ServletRequestAttributeListener session — HttpSessionAttributeListener servletContext — ServletContextAttributeListener request — ServletRequestAttributeListener session — HttpSessionAttributeListener 监听HttpSession中的存值状态这一类监听器不用注册 HttpSessionBindingListener123456789101. 让javaBean 实现该接口即可@Overridepublic void valueBound(HttpSessionBindingEvent event) &#123; System.out.println("对象被绑定进来了");&#125;@Overridepublic void valueUnbound(HttpSessionBindingEvent event) &#123; System.out.println("对象被解除绑定");&#125; 作用监听对象与session 绑定和解除绑定 的动作 HttpSessionActivationListener12345678910111213141516171819202122232425import java.io.Serializable;import javax.servlet.http.HttpSessionActivationListener;import javax.servlet.http.HttpSessionEvent;public class bean02 implements HttpSessionActivationListener,Serializable &#123; int a; public bean02(int a) &#123; super(); this.a = a; &#125; //get和set方法得写上不然通过jsp的EL表达式取不到值 public int getA() &#123; return a; &#125; public void setA(int a) &#123; this.a = a; &#125; public void sessionWillPassivate(HttpSessionEvent se) &#123; System.out.println("sessoin 钝化"); &#125; public void sessionDidActivate(HttpSessionEvent se) &#123; System.out.println("sessoin 活化"); &#125;&#125; 作用用于监听现在session的值 是 钝化 （序列化）还是活化 （反序列化）的动作 钝化 （序列化）把内存中的数据 存储到硬盘上 活化 （反序列化）把硬盘中的数据读取到内存中。 session的钝化活化的用意何在session中的值可能会很多， 并且我们有很长一段时间不使用这个内存中的值， 那么可以考虑把session的值可以存储到硬盘上【钝化】，等下一次在使用的时候，在从硬盘上提取出来。 【活化】 如何让session的在一定时间内钝化.做配置即可 123456789101112131415161718192021221. 在tomcat里面 conf/context.xml 里面配置 对所有的运行在这个服务器的项目生效 2. 在conf/Catalina/localhost/context.xml 配置 对 localhost生效。 localhost:80803. 在自己的web工程项目中的 META-INF/context.xml 只对当前的工程生效。 maxIdleSwap ： 1分钟不用就钝化 directory ： 钝化后的那个文件存放的目录位置，可自定义。 D:\tomcat\apache-tomcat-7.0.52\work\Catalina\localhost\ListenerDemo\wf &lt;Context&gt; &lt;Manager className=&quot;org.apache.catalina.session.PersistentManager&quot; maxIdleSwap=&quot;1&quot;&gt; &lt;Store className=&quot;org.apache.catalina.session.FileStore&quot; directory=&quot;wf&quot;/&gt; &lt;/Manager&gt; &lt;/Context&gt; Filter 过滤器，对客户端发出的请求进行过滤。在浏览器发出请求后，就由过滤器进行过滤，然后才交给servlet处理。其实过滤器起到拦截作用。 作用 对一些敏感词汇进行过滤 统一设置编码 自动登录 … 如何使用filter1.定义一个类实现Filter接口 123456789101112131415161718192021222324import java.io.IOException;import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;public class filter02 implements Filter &#123; //过滤器销毁时调用 public void destroy() &#123; &#125; //在执行过滤时调用 public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println("fliter02"); //chian的作用是当过滤器检测后，如果不用把请求过滤掉，那么就使用chain把请求传递到下一个地方。 chain.doFilter(request, response); &#125; //过滤器创建时调用 public void init(FilterConfig fConfig) throws ServletException &#123; &#125;&#125; 2.过滤器注册 在web.xml中注册和servlet注册方法基本一样 123456789&lt;filter&gt; &lt;display-name&gt;FilterDemo&lt;/display-name&gt; &lt;filter-name&gt;filter02&lt;/filter-name&gt; &lt;filter-class&gt;test4.filter02&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;filter02&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; Filter的生命周期创建 ​ 在服务器启动的时候就创建。 销毁 ​ 服务器停止的时候。 Filter执行顺序 客户端发出请求，先经过过滤器， 如果过滤器放行，那么才能到servlet 如果有多个过滤器， 那么他们会按照注册的映射顺序 来 排队。 只要有一个过滤器， 不放行，那么后面排队的过滤器以及咱们的servlet都不会收到请求。 Filter细节： init方法的参数 FilterConfig , 可以用于获取filter在注册的名字 以及初始化参数。 其实这里的设计的初衷与ServletConfig是一样的。 如果想放行，那么在doFilter 方法里面操作，使用参数 chain 1chain.doFilter(request, response); 放行， 让请求到达下一个目标。 /* 写法格式与servlet一样。 全路径匹配 以 / 开始 /LoginServlet 以目录匹配 以 / 开始 以 * 结束 /demo01/* 以后缀名匹配 以 * 开始 以后缀名结束 .jsp .html *.do 针对 dispatcher 设置 REQUEST ： 只要是请求过来，都拦截，默认就是REQUESTFORWARD : 只要是转发都拦截。ERROR ： 页面出错发生跳转INCLUDE ： 包含页面的时候就拦截。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>javaweb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis（1）入门]]></title>
    <url>%2F2019%2F04%2F15%2FMybatis%EF%BC%881%EF%BC%89%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Mybatis（1）入门1、mybatis的概述mybatis是一个持久层框架，用java编写的。它封装了jdbc操作的很多细节，使开发者只需要关注sql语句本身，而无需关注注册驱动，创建连接等繁杂过程它使用了ORM思想实现了结果集的封装。 ORM： Object Relational Mappging 对象关系映射 简单的说： 就是把数据库表和实体类及实体类的属性对应起来 让我们可以操作实体类就实现操作数据库表。123user Userid userIduser_name userName 今天我们需要做到实体类中的属性和数据库表的字段名称保持一致。123user Userid iduser_name user_name 2、mybatis的入门mybatis的环境搭建 2.1、创建maven工程并导入坐标配置\pom.xml 该文件导入了所有在工程中要使用的jar包。 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;wf&lt;/groupId&gt; &lt;artifactId&gt;day01_ssm_01mybatis&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2.2、创建实体类和dao的接口创建实体类src\main\java\domain\User.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package domain;import java.io.Serializable;import java.util.Date;import java.util.Objects;public class User implements Serializable &#123; private Integer id; private String username; private Date birthday; private String sex; private String address; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return "User&#123;" + "id=" + id + ", username='" + username + '\'' + ", birthday=" + birthday + ", sex='" + sex + '\'' + ", address='" + address + '\'' + '&#125;'; &#125;&#125; 配置dao接口\src\main\java\dao\IUserDao.java 12345678910111213141516package dao;import domain.User;import java.util.List;/** * 用户持久层接口 */public interface IUserDao &#123; /** * 查询所有操作 */ List&lt;User&gt; findAll();&#125; 2.3、创建Mybatis的主配置文件主配置文件\src\main\resources\SqlMapConfig.xml 12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;!--mybatis的主配置文件--&gt;&lt;configuration&gt; &lt;!--配置环境--&gt; &lt;environments default="mysql"&gt; &lt;!--配置MySQL的环境--&gt; &lt;environment id="mysql"&gt; &lt;!--配置事务类型--&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;!--配置数据源（连接池）--&gt; &lt;dataSource type="POOLED"&gt; &lt;!--配置连接池的基本信息4个--&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql:///eesy_mybatis"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="123456"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件--&gt; &lt;mappers&gt; &lt;mapper resource="dao/IUserDao.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 2.4、创建映射配置文件映射配置文件\src\main\resources\dao\IUserDao.xml 123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="dao.IUserDao"&gt; &lt;!--配置查询所有--&gt; &lt;select id="findAll" resultType="domain.User"&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 2.5、环境搭建的注意事项第一个：创建IUserDao.xml 和 IUserDao.java时名称是为了和我们之前的知识保持一致。 在Mybatis中它把持久层的操作接口名称和映射文件也叫做：Mapper 所以：IUserDao 和 IUserMapper是一样的第二个：在idea中创建目录的时候，它和包是不一样的 包在创建时：com.itheima.dao它是三级结构 目录在创建时：com.itheima.dao是一级目录第三个：mybatis的映射配置文件位置必须和dao接口的包结构相同第四个：映射配置文件的mapper标签namespace属性的取值必须是dao接口的全限定类名第五个：映射配置文件的操作配置（select），id属性的取值必须是dao接口的方法名 当我们遵从了第三，四，五点之后，我们在开发中就无须再写dao的实现类。 2.6、mybatis的入门案例第一步：读取配置文件第二步：创建SqlSessionFactory工厂第三步：创建SqlSession第四步：创建Dao接口的代理对象第五步：执行dao中的方法第六步：释放资源 注意事项： 不要忘记在映射配置中告知mybatis要封装到哪个实体类中(resultType) 123&lt;select id="findAll" resultType="domain.User"&gt; select * from user&lt;/select&gt; ​ 配置的方式：指定实体类的全限定类名 2.6.1、基于配置文件入门案例\src\test\java\test\MybatisTest.java 1234567891011121314151617181920212223242526272829303132333435package test;import dao.IUserDao;import domain.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.InputStream;import java.util.List;public class MybatisTest &#123; //入门案例 public static void main(String[] args) throws Exception &#123; //1 读取配置文件 InputStream in = Resources.getResourceAsStream("SqlMapConfig.xml"); //2 创建一个sqlSessionFactory工厂 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); SqlSessionFactory factory = builder.build(in); //3 使用工厂生成SqlSesasion对象 SqlSession session = factory.openSession(); //4 使用SqlSesasion对象创建Dao接口的代理对象 IUserDao userDao = session.getMapper(IUserDao.class); //5 使用代理对象执行方法 List&lt;User&gt; all = userDao.findAll(); for (User user:all) &#123; System.out.println(user); &#125; //6 释放资源 session.close(); in.close(); &#125;&#125; 2.6.2、mybatis基于注解的入门案例把IUserDao.xml移除，在dao接口的方法上使用@Select注解，并且指定SQL语句 1234567891011121314151617package dao;import domain.User;import org.apache.ibatis.annotations.Select;import java.util.List;/** * 用户持久层接口 */public interface IUserDao &#123; /** * 查询所有操作 */ @Select("select * from user") List&lt;User&gt; findAll();&#125; 同时需要在SqlMapConfig.xml中的mapper配置时，使用class属性指定dao接口的全限定类名。 123&lt;mappers&gt; &lt;mapper class="dao.IUserDao"/&gt;&lt;/mappers&gt; 明确： 我们在实际开发中，都是越简便越好，所以都是采用不写dao实现类的方式。 不管使用XML还是注解配置。 但是Mybatis它是支持写dao实现类的。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>javaee</tag>
        <tag>ssm框架</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[object类的概述]]></title>
    <url>%2F2019%2F04%2F15%2Fobject%E7%B1%BB%E7%9A%84%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[object类的概述 object类是类层次结构的根类，每个类都使用object作为超类。 即每个类都直接或间接的继承object类。 object类中方法介绍hashCode1public int hashCode():返回对象的哈希码值。 注意：哈希值是根据哈希算法计算出来的一个值，该值与地址值有关，但不是实际的值。可理解为地址值。 getClass1public final Class&lt;?&gt; getClass():返回object运行时类，得到一个Class对象。返回的 Class 对象是由所表示类的 static synchronized 方法锁定的对象。 在Class类中有getname()方法以 String 的形式返回此 Class 对象所表示的实体（类、接口、数组类、基本类型或 void）名称。 toString123456789101112public String toString():返回该对象的字符串表示。toString方法返回一个字符串，它的值等于： getClass().getName() + '@' + Integer.toHexString(hashCode())ps：Integer.toHexString（）为Integer类下一静态方法，public static String toHexString(int i)：以十六进制（基数 16）无符号整数形式返回一个整数参数的字符串表示形式。源码：public String toString() &#123; return getClass().getName() + "@"Integer.toHexString(hashCode()); &#125; 但toString方法返回的信息是无意义的。所以建议所以子类重写改方法。 重写的格式为：把所有成员变量值返回即可。但这样不是最好，自动生成即可。 12345678class Test&#123; int num; @Override public String toString() &#123; return "Test [num=" + num + "]"; &#125;&#125; 直接输出一个对象的名称，就是调用改对象的toString()方法。 equals12345public boolean equals(Object obj):指示其他某个对象是否与此对象“相等”。源码：public boolean equals(Object obj) &#123; return (this == obj); &#125; ==: ​ 基本类型：比较值是否相等。 ​ 引用类型：比较其地址值是否相等。 该方法，默认情况比较的是地址值，但是比较地址值意义不大，所以要重写改方法。 在方法重写时比较对象的成员变量值是否相同。 重写代码优化：提高效率，提高程序健壮性。 要想做到最好优化还是自动生成。（自动生成时会和hascode()方法一起生成。） 1234567891011121314151617181920212223242526272829303132class Test&#123; int num; String sfa; @Override public int hashCode() &#123; final int prime = 31; int result = 1; result = prime * result + num; result = prime * result + ((sfa == null) ? 0 : sfa.hashCode()); return result; &#125; @Override public boolean equals(Object obj) &#123; if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Test other = (Test) obj; if (num != other.num) return false; if (sfa == null) &#123; if (other.sfa != null) return false; &#125; else if (!sfa.equals(other.sfa)) return false; return true; &#125;&#125; 注：此为eclipse生成可能与idea生成的有所不同，但效果一样。 finalize1protected void finalize() throws Throwable :当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。 clone12protected Object clone() throws CloneNotSupportedException:创建并返回此对象的一个副本。“副本”的准确含义可能依赖于对象的类。 Cloneable：此类实现了Cloneable接口，以示Object.clone()方法合法的进行对该类的按字段复制。 Cloneable是一个标记接口，表明实现该接口的类可以实现对象的复制。]]></content>
      <categories>
        <category>Javase</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F14%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
